/*! RateIt | v1.0.22.1
    based on http://rateit.codeplex.com | Twitter: @gjunge
    modified: https://github.com/marten-seemann/rateit
*/
!function(a){
//touch converter http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/
function b(a){var b=a.originalEvent.changedTouches,c=b[0],d="";switch(a.type){case"touchmove":d="mousemove";break;case"touchend":d="mouseup";break;default:return}var e=document.createEvent("MouseEvent");e.initMouseEvent(d,!0,!0,window,1,c.screenX,c.screenY,c.clientX,c.clientY,!1,!1,!1,!1,0,null),c.target.dispatchEvent(e),a.preventDefault()}a.rateit={aria:{resetLabel:"reset rating",ratingLabel:"rating"}},a.fn.rateit=function(c,d){
//quick way out.
var e=1,f={},g="init",h=function(a){return a.charAt(0).toUpperCase()+a.substr(1)};if(0===this.length)return this;var i=a.type(c);if("object"==i||void 0===c||null===c)f=a.extend({},a.fn.rateit.defaults,c);else{if("string"==i&&"reset"!==c&&void 0===d)return this.data("rateit"+h(c));"string"==i&&(g="setvalue")}return this.each(function(){var i=a(this),j=function(a,b){if(null!=b){
//update aria values
var c="aria-value"+("value"==a?"now":a),d=i.find(".rateit-range");void 0!=d.attr(c)&&d.attr(c,b)}return arguments[0]="rateit"+h(a),i.data.apply(i,arguments)};
//handle programmatic reset
if("reset"==c){var k=j("init");//get initial value
for(var l in k)i.data(l,k[l]);if(j("backingfld")){//reset also backingfield
var m=a(j("backingfld"));m.val(j("value")),m.trigger("change"),m[0].min&&(m[0].min=j("min")),m[0].max&&(m[0].max=j("max")),m[0].step&&(m[0].step=j("step"))}i.trigger("reset")}
//add the rate it class.
i.hasClass("rateit")||i.addClass("rateit");var n="rtl"!=i.css("direction");
// set value mode
if("setvalue"==g){if(!j("init"))throw"Can't set value before init";if(
//if readonly now and it wasn't readonly, remove the eventhandlers.
"readonly"!=c||1!=d||j("readonly")||(i.find(".rateit-range").unbind(),j("wired",!1)),
//when we receive a null value, reset the score to its min value.
"value"==c&&(d=null==d?j("min"):Math.max(j("min"),Math.min(j("max"),d))),j("backingfld")){
//if we have a backing field, check which fields we should update.
//In case of input[type=range], although we did read its attributes even in browsers that don't support it (using fld.attr())
//we only update it in browser that support it (&& fld[0].min only works in supporting browsers), not only does it save us from checking if it is range input type, it also is unnecessary.
var m=a(j("backingfld"));"value"==c&&m.val(d),"min"==c&&m[0].min&&(m[0].min=d),"max"==c&&m[0].max&&(m[0].max=d),"step"==c&&m[0].step&&(m[0].step=d)}j(c,d)}
//init rateit plugin
if(!j("init")){
//are we LTR or RTL?
if(
//get our values, either from the data-* html5 attribute or from the options.
j("min",isNaN(j("min"))?f.min:j("min")),j("max",isNaN(j("max"))?f.max:j("max")),j("step",j("step")||f.step),j("readonly",void 0!==j("readonly")?j("readonly"):f.readonly),j("resetable",void 0!==j("resetable")?j("resetable"):f.resetable),j("backingfld",j("backingfld")||f.backingfld),j("starwidth",j("starwidth")||f.starwidth),j("starheight",j("starheight")||f.starheight),j("value",Math.max(j("min"),Math.min(j("max"),isNaN(j("value"))?isNaN(f.value)?f.min:f.value:j("value")))),j("ispreset",void 0!==j("ispreset")?j("ispreset"):f.ispreset),j("backingfld")){
//if we have a backing field, hide it, override defaults if range or select.
var m=a(j("backingfld")).hide();if((m.attr("disabled")||m.attr("readonly"))&&j("readonly",!0),"INPUT"==m[0].nodeName&&("range"==m[0].type||"text"==m[0].type)&&(//in browsers not support the range type, it defaults to text
j("min",parseInt(m.attr("min"))||j("min")),//if we would have done fld[0].min it wouldn't have worked in browsers not supporting the range type.
j("max",parseInt(m.attr("max"))||j("max")),j("step",parseInt(m.attr("step"))||j("step"))),"SELECT"==m[0].nodeName&&m[0].options.length>1){j("min",isNaN(j("min"))?Number(m[0].options[0].value):j("min")),j("max",Number(m[0].options[m[0].length-1].value)),j("step",Number(m[0].options[1].value)-Number(m[0].options[0].value));
//see if we have a option that as explicity been selected
var o=m.find("option[selected]");1==o.length&&j("value",o.val())}else
//if it is not a select box, we can get's it's value using the val function.
//If it is a selectbox, we always get a value (the first one of the list), even if it was not explicity set.
j("value",m.val())}
//Create the necessary tags. For ARIA purposes we need to give the items an ID. So we use an internal index to create unique ids
var p="DIV"==i[0].nodeName?"div":"span";e++;var q='<button id="rateit-reset-{{index}}" type="button" data-role="none" class="rateit-reset" aria-label="'+a.rateit.aria.resetLabel+'" aria-controls="rateit-range-{{index}}"></button><{{element}} id="rateit-range-{{index}}" class="rateit-range" tabindex="0" role="slider" aria-label="'+a.rateit.aria.ratingLabel+'" aria-owns="rateit-reset-{{index}}" aria-valuemin="'+j("min")+'" aria-valuemax="'+j("max")+'" aria-valuenow="'+j("value")+'"><{{element}} class="rateit-selected" style="height:'+j("starheight")+'px"></{{element}}><{{element}} class="rateit-hover" style="height:'+j("starheight")+'px"></{{element}}></{{element}}>';i.append(q.replace(/{{index}}/gi,e).replace(/{{element}}/gi,p)),
//if we are in RTL mode, we have to change the float of the "reset button"
n||(i.find(".rateit-reset").css("float","right"),i.find(".rateit-selected").addClass("rateit-selected-rtl"),i.find(".rateit-hover").addClass("rateit-hover-rtl")),j("init",JSON.parse(JSON.stringify(i.data())))}
//resize the height of all elements,
i.find(".rateit-selected, .rateit-hover").height(j("starheight"));
//set the range element to fit all the stars.
var r=i.find(".rateit-range");r.width(j("starwidth")*(j("max")-j("min"))).height(j("starheight"));
//add/remove the preset class
var s="rateit-preset"+(n?"":"-rtl");
//set the value if we have it.
if(j("ispreset")?i.find(".rateit-selected").addClass(s):i.find(".rateit-selected").removeClass(s),null!=j("value")){var t=(j("value")-j("min"))*j("starwidth");i.find(".rateit-selected").width(t)}
//setup the reset button
var u=i.find(".rateit-reset");u.data("wired")!==!0&&u.bind("click",function(b){b.preventDefault(),u.blur();var c=a.Event("beforereset");return i.trigger(c),c.isDefaultPrevented()?!1:(i.rateit("value",null),void i.trigger("reset"))}).data("wired",!0);
//this function calculates the score based on the current position of the mouse.
var v=function(b,c){var d=c.changedTouches?c.changedTouches[0].pageX:c.pageX,e=d-a(b).offset().left;return n||(e=r.width()-e),e>r.width()&&(e=r.width()),0>e&&(e=0),t=Math.ceil(e/j("starwidth")*(1/j("step")))},w=function(a){var b=a*j("starwidth")*j("step"),c=r.find(".rateit-hover");if(c.data("width")!=b){r.find(".rateit-selected").hide(),c.width(b).show().data("width",b);var d=[a*j("step")+j("min")];i.trigger("hover",d).trigger("over",d)}},x=function(b){var c=a.Event("beforerated");//if it was a preset value, unset that.
return i.trigger(c,[b]),c.isDefaultPrevented()?!1:(j("value",b),j("backingfld")&&a(j("backingfld")).val(b).trigger("change"),j("ispreset")&&(r.find(".rateit-selected").removeClass(s),j("ispreset",!1)),r.find(".rateit-hover").hide(),r.find(".rateit-selected").width(b*j("starwidth")-j("min")*j("starwidth")).show(),i.trigger("hover",[null]).trigger("over",[null]).trigger("rated",[b]),!0)};j("readonly")?u.hide():(
//if we are not read only, add all the events
//if we have a reset button, set the event handler.
j("resetable")||u.hide(),
//when the mouse goes over the range element, we set the "hover" stars.
j("wired")||(r.bind("touchmove touchend",b),//bind touch events
r.mousemove(function(a){var b=v(this,a);w(b)}),
//when the mouse leaves the range, we have to hide the hover stars, and show the current value.
r.mouseleave(function(a){r.find(".rateit-hover").hide().width(0).data("width",""),i.trigger("hover",[null]).trigger("over",[null]),r.find(".rateit-selected").show()}),
//when we click on the range, we have to set the value, hide the hover.
r.mouseup(function(a){var b=v(this,a),c=b*j("step")+j("min");x(c),r.blur()}),
//support key nav
r.keyup(function(a){(38==a.which||a.which==(n?39:37))&&x(Math.min(j("value")+j("step"),j("max"))),(40==a.which||a.which==(n?37:39))&&x(Math.max(j("value")-j("step"),j("min")))}),j("wired",!0)),j("resetable")&&u.show()),r.attr("aria-readonly",j("readonly"))})},
//some default values.
a.fn.rateit.defaults={min:0,max:5,step:.5,starwidth:16,starheight:16,readonly:!1,resetable:!0,ispreset:!1},
//invoke it on all .rateit elements. This could be removed if not wanted.
a(function(){a("div.rateit, span.rateit").rateit()})}(jQuery);